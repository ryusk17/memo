module Stocks
  class UpdateQuantity
    include Callable

    def initialize(stock:, stock_log:, batch_size: nil)
      @stock = stock
      @stock_log = stock_log
      @batch_size = batch_size
      @stock_monthly_hash = {}
    end

    # 論理在庫数(stock.quantity)を計算し、更新する。
    # stock.calculated_logged_at よりも最近の stock_log を取得して、加減算してゆく。
    def call
      @stock.reset if need_reset_stock?

      StockLog.find_uncalculated_each(@stock, batch_size: @batch_size) do |log|
        before_quantity = @stock.quantity
        before_order_items = @stock.order_items.deep_dup
        before_calculated_year_month = @stock.calculated_year_month

        calculate_stock_log log

        update_stock_monthly log, before_quantity, before_order_items, before_calculated_year_month
      end

      @stock.save!
      @stock_monthly_hash.each_value(&:save)

      @stock
    end

    private

    # @stock_log.logged_at と @stock.calculated_logged_at を比較して、
    # @stock_log.logged_at の方が過去の時間だった場合、再計算が必要なため reset が必要と判定する
    # 時刻が同じ場合は PK で比較する
    def need_reset_stock?
      return false unless @stock.calculated_logged_at

      return true if @stock_log.logged_at < @stock.calculated_logged_at

      @stock_log.logged_at == @stock.calculated_logged_at && @stock_log.id < @stock.calculated_log_id
    end

    def calculate_stock_log(stock_log)
      before_quantity = @stock.quantity
      delta_quantity = if stock_log.stocktaking? || stock_log.fix_quantity?
                         # 棚卸しや在庫調整の時は在庫数が fifo_rack.quantity の値になるようにする
                         stock_log.delta_quantity - before_quantity
                       else
                         stock_log.delta_quantity
                       end

      @stock.quantity += delta_quantity
      if delta_quantity.positive?
        increase_order_items(@stock.order_items, delta_quantity, stock_log, before_quantity)
      else
        decrease_order_items(@stock.order_items, -delta_quantity)
      end

      @stock.calculated_logged_at = stock_log.logged_at
      @stock.calculated_log_id = stock_log.id

      Rails.logger.debug @stock
      @stock.last_action = stock_log.action
      @stock.last_acted_at = stock_log.logged_at
    end

    def update_stock_monthly(stock_log, before_quantity, before_order_items, before_calculated_year_month)
      calculated_year_month = @stock.calculated_year_month
      stock_monthly = stock_monthly_by calculated_year_month

      if before_calculated_year_month && before_calculated_year_month != calculated_year_month
        stock_monthly.start_quantity = before_quantity
        stock_monthly.start_order_items = before_order_items
      end

      update_stock_monthly_delte_quantity stock_monthly, stock_log
    end

    def stock_monthly_by(calculated_year_month)
      stock_monthly = @stock_monthly_hash[calculated_year_month]
      return stock_monthly if stock_monthly

      stock_monthly = @stock.monthly
      stock_monthly ||= StockMonthly.new(
        pharmacy_id: @stock.pharmacy_id,
        stock: @stock,
        year_month: calculated_year_month,
      )
      @stock_monthly_hash[calculated_year_month] = stock_monthly

      stock_monthly
    end

    def update_stock_monthly_delte_quantity(stock_monthly, stock_log)
      if stock_log.purchase?
        stock_monthly.purchase += stock_log.delta_quantity
      elsif stock_log.dispense?
        stock_monthly.dispense -= stock_log.delta_quantity
      elsif stock_log.delta_quantity.positive?
        stock_monthly.other_in += stock_log.delta_quantity
      else
        stock_monthly.other_out -= stock_log.delta_quantity
      end
    end

    # 包装単位別に論理在庫を増加させる。
    # 使用期限やLOT番号などある場合は一緒に記録する。
    def increase_order_items(order_items, delta_quantity, stock_log, before_quantity)
      # order_items に同じ包装単位がある場合はそこに個数を追加する
      found_index = find_order_item_index(order_items, stock_log.options)
      unless found_index.nil?
        order_items[found_index][:quantity] += delta_quantity
        return
      end

      order_item = new_order_item(delta_quantity, stock_log.options)

      if before_quantity.negative?
        order_item[:quantity] += before_quantity
        return if order_item[:quantity] <= 0
      end

      order_items.push(order_item)
      sort_order_items(order_items)
    end

    # 包装単位別に論理在庫を減少させる。
    def decrease_order_items(order_items, decrease_quantity)
      while !order_items.empty? && decrease_quantity.positive?
        if order_items.first[:quantity] < decrease_quantity
          decrease_quantity -= order_items.first[:quantity]
          order_items.shift
        else
          order_items.first[:quantity] -= decrease_quantity
          decrease_quantity = 0
        end
      end
    end

    def find_order_item_index(order_items, options)
      order_items.index do |order_item|
        if order_item[:orderable_item_id] != options[:orderable_item_id] ||
          order_item[:lot] != options[:lot] ||
          order_item[:expires_on] != options[:expires_on]
          false
        else
          true
        end
      end
    end

    def new_order_item(delta_quantity, options)
      order_item = {
        quantity: delta_quantity,
      }

      order_item[:orderable_item_id] = options[:orderable_item_id] if options[:orderable_item_id]
      order_item[:expires_on] = options[:expires_on] if options[:expires_on]
      order_item[:lot] = options[:lot] if options[:lot]
      order_item
    end

    # 使用期限が近い順にソートし、前から順番に消費させる
    # 使用期限が不明のものはソートで前におく。情報が不足なデータは早く消費して、消える方向に持っていきたいので。
    def sort_order_items(order_items)
      order_items.sort! do |a, b|
        if a[:expires_on] != b[:expires_on]
          compare_expires_on(a, b)
        elsif a[:orderable_item_id].nil? && b[:orderable_item_id]
          -1
        elsif b[:orderable_item_id].nil? && a[:orderable_item_id]
          1
        else
          0
        end
      end
    end

    def compare_expires_on(a, b)
      if a[:expires_on].nil?
        -1
      elsif b[:expires_on].nil?
        1
      else
        a[:expires_on] <=> b[:expires_on]
      end
    end
  end
end
