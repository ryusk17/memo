import math

# from matplotlib import pyplot as plt
# from mpl_toolkits.mplot3d import Axes3D



import os



def functor(f, l):
    if isinstance(l,list):
        return [functor(f,i) for i in l]
    else:
        return f(l)


def sign(x):
    return 0.0 if abs(x) == 0 else x / abs(x)

R_EARTH =  63780000
# R_EARTH =  10000

N = 3

# TODO: 畑の緯度経度のポイントリスト
# スタート位置（左手前）、奥、隣、手前、隣、奥、隣、手前、隣、奥、隣、手前、隣、奥 ...n
FILEPATH = './coord_gps.txt'
def get_gps_coords():
    with open(FILEPATH, 'r') as f:
    # with open('test.txt', 'r') as f:
        # coords = [[float(e[0]), float(e[1])] for s in f.readlines() for e in s.strip()]
        coords_gps = [s.strip().split(',') for s in f.readlines()]


    coords_gps = functor(float, coords_gps)
    # [00, 01, 11, 10, 20, .... ]の状態


    # y=1, 2 を分離する
    tp1_gps = []
    tp2_gps = []

    for i, coord in enumerate(coords_gps):
        if i % 4 in {0, 3}:
            tp1_gps.append(tuple(coord))
        else:
            tp2_gps.append(tuple(coord))


    t1_gps = [math.radians(e[0]) for e in tp1_gps]
    p1_gps = [math.radians(e[1]) for e in tp1_gps]
    t2_gps = [math.radians(e[0]) for e in tp2_gps]
    p2_gps = [math.radians(e[1]) for e in tp2_gps]

    # 立体にする
    x1 = [R_EARTH * math.cos(t1_gps[i]) * math.cos(xx) for i, xx in enumerate(p1_gps)]
    y1 = [R_EARTH * math.cos(t1_gps[i]) * math.sin(xx) for i, xx in enumerate(p1_gps)]
    z1 = [R_EARTH * math.sin(yy) for yy in t1_gps]

    x2 = [R_EARTH * math.cos(t2_gps[i]) * math.cos(xx) for i, xx in enumerate(p2_gps)]
    y2 = [R_EARTH * math.cos(t2_gps[i]) * math.sin(xx) for i, xx in enumerate(p2_gps)]
    z2 = [R_EARTH * math.sin(yy) for yy in t2_gps]

    x3 = [(x2[i] + N * (x2[i] - x1[i])/math.sqrt((x1[i] - x2[i])**2 + (y2[i] - y1[i])**2 + (z2[i]-z1[i]) ** 2)) for i in range(len(x1))]
    y3 = [(y2[i] + N * (y2[i] - y1[i])/math.sqrt((x1[i] - x2[i])**2 + (y2[i] - y1[i])**2 + (z2[i]-z1[i]) ** 2)) for i in range(len(x1))]
    z3 = [(z2[i] + N * (z2[i] - z1[i])/math.sqrt((x1[i] - x2[i])**2 + (y2[i] - y1[i])**2 + (z2[i]-z1[i]) ** 2)) for i in range(len(x1))]

    x0 = [(x1[i] - N * (x2[i] - x1[i])/math.sqrt((x1[i] - x2[i])**2 + (y2[i] - y1[i])**2 + (z2[i]-z1[i]) ** 2)) for i in range(len(x1))]
    y0 = [(y1[i] - N * (y2[i] - y1[i])/math.sqrt((x1[i] - x2[i])**2 + (y2[i] - y1[i])**2 + (z2[i]-z1[i]) ** 2)) for i in range(len(x1))]
    z0 = [(z1[i] - N * (z2[i] - z1[i])/math.sqrt((x1[i] - x2[i])**2 + (y2[i] - y1[i])**2 + (z2[i]-z1[i]) ** 2)) for i in range(len(x1))]

    for i in range(len(x0)):
        x0[i] *= R_EARTH / math.sqrt(x0[i] ** 2 + y0[i] ** 2 + z0[i] ** 2)
        y0[i] *= R_EARTH / math.sqrt(x0[i] ** 2 + y0[i] ** 2 + z0[i] ** 2)
        z0[i] *= R_EARTH / math.sqrt(x0[i] ** 2 + y0[i] ** 2 + z0[i] ** 2)

    for i in range(len(x3)):
        x3[i] *= R_EARTH / math.sqrt(x3[i] ** 2 + y3[i] ** 2 + z3[i] ** 2)
        y3[i] *= R_EARTH / math.sqrt(x3[i] ** 2 + y3[i] ** 2 + z3[i] ** 2)
        z3[i] *= R_EARTH / math.sqrt(x3[i] ** 2 + y3[i] ** 2 + z3[i] ** 2)

    t0_gps = [math.degrees(math.asin(z0[i] / math.sqrt(x0[i]**2 + y0[i]**2 + z0[i]**2))) for i in range(len(x0))]
    p0_gps = [math.degrees(sign(y0[i]) * math.acos(x0[i] / math.sqrt(x0[i]**2 + y0[i]**2))) for i in range(len(x0))]

    t3_gps = [math.degrees(math.asin(z3[i] / math.sqrt(x3[i]**2 + y3[i]**2 + z3[i]**2))) for i in range(len(x3))]
    p3_gps = [math.degrees(sign(y3[i]) * math.acos(x3[i] / math.sqrt(x3[i]**2 + y3[i]**2))) for i in range(len(x3))]


    all_coords_gps = tuple(((t0_gps[i], p0_gps[i]), tuple(tp1_gps[i]), tuple(tp2_gps[i]), (t3_gps[i], p3_gps[i])) for i in range(len(x1)))
    #
    # x0 = [R_EARTH * math.cos(coords[0][1]) * math.cos(coords[0][0]) for coords in all_coords_gps]
    # y0 = [R_EARTH * math.cos(coords[0][1]) * math.sin(coords[0][0]) for coords in all_coords_gps]
    # z0 = [R_EARTH * math.sin(coords[0][1]) for coords in all_coords_gps]
    #
    # x1 = [R_EARTH * math.cos(coords[1][1]) * math.cos(coords[1][0]) for coords in all_coords_gps]
    # y1 = [R_EARTH * math.cos(coords[1][1]) * math.sin(coords[1][0]) for coords in all_coords_gps]
    # z1 = [R_EARTH * math.sin(coords[1][1]) for coords in all_coords_gps]
    #
    # x2 = [R_EARTH * math.cos(coords[2][1]) * math.cos(coords[2][0]) for coords in all_coords_gps]
    # y2 = [R_EARTH * math.cos(coords[2][1]) * math.sin(coords[2][0]) for coords in all_coords_gps]
    # z2 = [R_EARTH * math.sin(coords[2][1]) for coords in all_coords_gps]
    #
    # x3 = [R_EARTH * math.cos(coords[3][1]) * math.cos(coords[3][0]) for coords in all_coords_gps]
    # y3 = [R_EARTH * math.cos(coords[3][1]) * math.sin(coords[3][0]) for coords in all_coords_gps]
    # z3 = [R_EARTH * math.sin(coords[3][1]) for coords in all_coords_gps]
    #
    #
    # fig = plt.figure() #プロット領域の作成
    # ax = Axes3D(fig)
    #
    # ax.plot(x1, y1, z1, marker='o', linestyle='None', color='k')
    # ax.plot(x2, y2, z2, marker='o', linestyle='None', color='k')
    # ax.plot(x0, y0, z0, marker='.', linestyle='None', color='r')
    # ax.plot(x3, y3, z3, marker='.', linestyle='None', color='b')
    #
    #
    #
    # plt.show()

    return all_coords_gps


if __name__ == '__main__':
    from matplotlib import pyplot as plt
    from mpl_toolkits.mplot3d import Axes3D
    import numpy as np

    coords_gps = get_gps_coords()

    x0 = [R_EARTH * math.cos(math.radians(coords[0][1])) * math.cos(math.radians(coords[0][0])) for coords in coords_gps]
    y0 = [R_EARTH * math.cos(math.radians(coords[0][1])) * math.sin(math.radians(coords[0][0])) for coords in coords_gps]
    z0 = [R_EARTH * math.sin(math.radians(coords[0][1])) for coords in coords_gps]

    x1 = [R_EARTH * math.cos(math.radians(coords[1][1])) * math.cos(math.radians(coords[1][0])) for coords in coords_gps]
    y1 = [R_EARTH * math.cos(math.radians(coords[1][1])) * math.sin(math.radians(coords[1][0])) for coords in coords_gps]
    z1 = [R_EARTH * math.sin(math.radians(coords[1][1])) for coords in coords_gps]

    x2 = [R_EARTH * math.cos(math.radians(coords[2][1])) * math.cos(math.radians(coords[2][0])) for coords in coords_gps]
    y2 = [R_EARTH * math.cos(math.radians(coords[2][1])) * math.sin(math.radians(coords[2][0])) for coords in coords_gps]
    z2 = [R_EARTH * math.sin(math.radians(coords[2][1])) for coords in coords_gps]

    x3 = [R_EARTH * math.cos(math.radians(coords[3][1])) * math.cos(math.radians(coords[3][0])) for coords in coords_gps]
    y3 = [R_EARTH * math.cos(math.radians(coords[3][1])) * math.sin(math.radians(coords[3][0])) for coords in coords_gps]
    z3 = [R_EARTH * math.sin(math.radians(coords[3][1])) for coords in coords_gps]

    print('x0: t, p', coords_gps[0][0][0], coords_gps[0][0][1])
    print('x1; t, p', coords_gps[0][1][0], coords_gps[0][1][1])

    print('距離', math.sqrt((x0[0] - x1[0]) ** 2 + (y0[0] - y1[0]) ** 2 + (z0[0] - z1[0]) ** 2))

    fig = plt.figure() #プロット領域の作成
    ax = Axes3D(fig)

    ax.plot(x1, y1, z1, marker='o', linestyle='None', color='k')
    ax.plot(x2, y2, z2, marker='o', linestyle='None', color='k')
    ax.plot(x0, y0, z0, marker='.', linestyle='None', color='r')
    ax.plot(x3, y3, z3, marker='.', linestyle='None', color='b')
#
#     # ax = fig.gca(projection='3d') #プロット中の軸の取得。gca は"Get Current Axes" の略。
#
#     # x = np.arange(-2, 2, 0.05) # x点として[-2, 2]まで0.05刻みでサンプル
#     # y = np.arange(-2, 2, 0.05)  # y点として[-2, 2]まで0.05刻みでサンプル
#     # x, y = np.meshgrid(x, y)  # 上述のサンプリング点(x,y)を使ったメッシュ生成
#     # z = np.exp(-(x**2 + y**2))  #exp(-(x^2+y^2))  を計算してzz座標へ格納する。
#
#     # ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap='hsv', linewidth=0.3) # 曲面のプロット。rstrideとcstrideはステップサイズ，cmapは彩色，linewidthは曲面のメッシュの線の太さ，をそれぞれ表す。
#
#     for coord in coords_xyz:
#         x = [e[0] for e in coord]
#         y = [e[1] for e in coord]
#         z = [e[2] for e in coord]
#         print(x)
#         # ax.plot(x, y, z, marker='.', linestyle='None', color='k')
#         ax.plot((x[1], x[2]), (y[1], y[2]), (z[1], z[2]), marker='.', linestyle='None', color='b')
#         # ax.plot((x[0], x[3]), (y[0], y[3]), (z[0], z[3]), marker='.', linestyle='None', color='r')
#
#         ax.plot((x[1], x[2]), (y[1], y[2]), (z[1], z[2]), color='#daa520', linewidth='3')
# #
#
#
#
#     # for a in r_ax:
#     #     ax.plot([x1[0], a[0]], [y1[0], a[1]], [z1[0], a[2]], color='b')
#
#
#
    plt.show() # 絵の出力。
